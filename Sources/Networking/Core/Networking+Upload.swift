//
//  Networking+Upload.swift
//  Networking
//
//  MIT License
//
//  Copyright (c) 2025 Networking - Yağızhan Akduman
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//

import Foundation

// MARK: - Upload
extension Networking {
    
    /// Uploads multipart form data using a synchronous-style API that internally dispatches to an async context.
    ///
    /// This method serves as a bridge between legacy synchronous APIs and Swift's modern concurrency system (`async/await`).
    /// Internally, it launches a new asynchronous `Task` to handle the upload logic, making it suitable for use in non-async contexts
    /// such as delegate methods or UIKit actions.
    ///
    /// - Parameters:
    ///   - url: The `URL` to which the multipart form data will be uploaded.
    ///          - This is typically an API endpoint that accepts file or form uploads (e.g., `https://api.example.com/upload`).
    ///
    ///   - method: The `HTTPMethod` to use for the request (default: `.post`).
    ///             - Common values include `.post` and `.put`, depending on your backend's API specification.
    ///             - Some APIs may reject uploads that do not use the expected method.
    ///
    ///   - headers: Optional `HTTPHeaders` to include in the request, such as authentication tokens or content-type overrides.
    ///              - These headers will be merged with those generated by the multipart form data builder.
    ///              - For example, you might pass `["Authorization": "Bearer <token>"]`.
    ///
    ///   - progress: An optional closure providing **real-time upload progress updates** as a `Double` in the range `0.0...1.0`.
    ///               - Called periodically as data is transferred to the server.
    ///               - Useful for displaying a progress bar or updating UI status.
    ///
    ///   - multipartFormData: A throwing closure that uses `MultipartFormDataBuilder` to construct the multipart payload.
    ///                        - You can append files, text values, and binary data to the form.
    ///                        - If an error is thrown during this phase (e.g., invalid file URL), it will be caught and handled.
    ///
    ///   - completion: A closure that is called after the upload finishes, with a `NetworkingResponse<T>`:
    ///                 - `.success(T)`: Upload succeeded and response data was decoded into type `T`.
    ///                 - `.failure(NetworkError)`: Upload failed due to a network or decoding error.
    ///                 - Called on the main thread by default for safe UI updates.
    ///
    /// - Returns:
    ///   - Always returns `nil`, as the caller is not expected to manage the underlying `URLSessionUploadTask`.
    ///     Upload progress and result are delivered exclusively via the `progress` and `completion` handlers.
    ///
    /// - Note:
    ///   - This method is **not cancelable** since it does not expose the underlying `URLSessionUploadTask`.
    ///     For cancellation or finer control, use the `async` variant of `uploadMultipart(...)`.
    ///   - Errors thrown inside the `multipartFormData` builder or during the async operation will be captured
    ///     and forwarded as a `.failure(.unknown(error))` in the `completion` callback.
    ///
    /// - Example Usage:
    ///   ```swift
    ///   networking.uploadMultipart(
    ///       to: URL(string: "https://api.example.com/upload")!,
    ///       headers: ["Authorization": "Bearer token"],
    ///       progress: { progress in
    ///           print("Upload progress: \(progress * 100)%")
    ///       },
    ///       multipartFormData: { builder in
    ///           try builder.append(fileURL, withName: "image", fileName: "photo.jpg", mimeType: "image/jpeg")
    ///           try builder.append("john_doe", withName: "username")
    ///       },
    ///       completion: { (response: NetworkingResponse<UploadResultModel>) in
    ///           switch response.result {
    ///           case .success(let value):
    ///               print("Upload successful:", value)
    ///           case .failure(let error):
    ///               print("Upload failed:", error)
    ///           }
    ///       }
    ///   )
    ///   ```
    ///
    /// - Thread Safety:
    ///   - This method is thread-safe and can be invoked from any thread.
    ///   - The internal upload operation is executed asynchronously within a separate `Task`, ensuring that the main thread remains responsive.
    ///   - The `completion` and `progress` callbacks are dispatched on the main thread for UI safety.
    @discardableResult
    public func uploadMultipart<T: Decodable>(to url: URL, method: HTTPMethod = .post, headers: HTTPHeaders? = nil, progress: ((Double) -> Void)? = nil, multipartFormData: @escaping (MultipartFormDataBuilder) throws -> Void, completion: @escaping (NetworkingResponse<T>) -> Void) -> URLSessionUploadTask? {
        return uploader.uploadMultipart(to: url, method: method, headers: headers, progress: progress, multipartFormData: multipartFormData, completion: completion)
    }
    
    /// Uploads multipart form data as an asynchronous request using Swift concurrency (`async/await`).
    ///
    /// This method constructs a `multipart/form-data` HTTP request that can include both binary files and text fields,
    /// and uploads it to the specified server endpoint. It is suited for submitting files with metadata, form values,
    /// or other structured content using a single HTTP request.
    ///
    /// Internally, the request is executed via `URLSessionUploadTask` and provides closure-based upload progress
    /// and a strongly-typed response model upon completion.
    ///
    /// - Parameters:
    ///   - url: The `URL` to which the multipart form data will be uploaded.
    ///          - Typically a file or media upload endpoint, e.g., `https://api.example.com/upload`.
    ///
    ///   - method: The HTTP method to use (default: `.post`).
    ///             - Acceptable values include `.post` and `.put`, depending on backend API requirements.
    ///
    ///   - headers: Optional headers to include with the request.
    ///              - For example: `Authorization`, `Content-Type`, or any custom backend-specific headers.
    ///              - If provided, these headers will override default values set internally.
    ///
    ///   - progress: A closure called periodically with upload progress as a `Double` from `0.0` to `1.0`.
    ///               - Useful for showing upload progress in UI.
    ///
    ///   - multipartFormData: A throwing closure that configures the multipart form body via `MultipartFormDataBuilder`.
    ///                        - You can append files, key-value fields, binary blobs, and form data.
    ///                        - If an error is thrown, the upload is canceled and the error is passed to `completion`.
    ///
    ///   - completion: A closure invoked after the upload is completed.
    ///                 - Returns a `NetworkingResponse<T>`:
    ///                   - `.success(T)`: If the server returns valid data and decoding succeeds.
    ///                   - `.failure(NetworkError)`: For upload, decoding, or connectivity failures.
    ///
    /// - Returns:
    ///   - A `URLSessionUploadTask?` instance if the upload was successfully initiated; otherwise `nil`.
    ///     - The task begins immediately via `resume()`.
    ///
    /// - Throws:
    ///   - Rethrows any error that occurs while building the multipart form body in `multipartFormData`.
    ///   - Common errors include invalid file paths, data encoding issues, or form construction problems.
    ///
    /// - Note:
    ///   - The request content type is automatically set to `multipart/form-data` with a unique boundary string.
    ///   - Each file must have a valid MIME type (`image/png`, `application/pdf`, etc.) and a proper `fieldName`.
    ///   - This method does not support task cancellation directly; retain and cancel the returned task manually if needed.
    ///   - Always consider backend constraints such as maximum allowed upload size, authentication, and timeout settings.
    ///
    /// - Example Usage:
    ///   ```swift
    ///   let task = try await networking.uploadMultipart(
    ///       to: URL(string: "https://api.example.com/upload")!,
    ///       headers: ["Authorization": "Bearer token"],
    ///       progress: { progress in
    ///           print("Upload progress: \(progress * 100)%")
    ///       },
    ///       multipartFormData: { builder in
    ///           try builder.append(fileURL, withName: "image", fileName: "photo.jpg", mimeType: "image/jpeg")
    ///           try builder.append("john_doe", withName: "username")
    ///       },
    ///       completion: { (response: NetworkingResponse<UploadResponseModel>) in
    ///           switch response.result {
    ///           case .success(let result):
    ///               print("Upload succeeded:", result)
    ///           case .failure(let error):
    ///               print("Upload failed:", error)
    ///           }
    ///       }
    ///   )
    ///   ```
    ///
    /// - Thread Safety:
    ///   - Thread-safe. Internal state (`activeUploads`) is protected using a dedicated `DispatchQueue`.
    ///   - The `progress` and `completion` closures may be called on a background thread. Ensure UI updates happen on the main thread.
    ///   - This function can safely be called from any thread; the upload itself is handled asynchronously.
    @discardableResult
    public func uploadMultipart<T: Decodable>(to url: URL, method: HTTPMethod = .post, headers: HTTPHeaders? = nil, progress: ((Double) -> Void)?, multipartFormData: (MultipartFormDataBuilder) throws -> Void, completion: @escaping (NetworkingResponse<T>) -> Void) async rethrows -> URLSessionUploadTask? {
        return try await uploader.uploadMultipart(to: url, method: method, headers: headers, progress: progress, multipartFormData: multipartFormData, completion: completion)
    }
    
    /// Uploads raw binary data using a synchronous-style API that internally dispatches to an async context.
    ///
    /// This method acts as a compatibility layer for codebases that cannot use Swift's `async/await` syntax directly.
    /// Internally, it starts an asynchronous task to perform the upload using `uploadRawData(...)`.
    /// The upload progress and result are reported through closure-based handlers, making it ideal for UIKit delegates and legacy code.
    ///
    /// - Parameters:
    ///   - url: The `URL` to which the binary data will be uploaded.
    ///          - Should point to a valid server endpoint accepting raw uploads.
    ///
    ///   - method: The HTTP method to use (default: `.post`).
    ///             - Usually `.post` or `.put`, depending on backend API requirements.
    ///
    ///   - data: The raw binary `Data` to be uploaded.
    ///           - Typically read from disk (e.g., file contents) or generated in memory.
    ///
    ///   - headers: Optional `HTTPHeaders` to include in the request.
    ///              - Useful for setting authentication, content type overrides, etc.
    ///
    ///   - progress: An optional closure reporting upload progress as a `Double` (0.0...1.0).
    ///               - Called periodically throughout the upload.
    ///
    ///   - completion: A closure called upon completion, returning a `NetworkingResponse<T>`:
    ///                 - `.success(T)`: The decoded server response.
    ///                 - `.failure(NetworkError)`: Indicates a transport, decoding, or adaptation error.
    ///
    /// - Returns:
    ///   - Always returns `nil`, as the internal task is handled asynchronously within a `Task`.
    ///     Use the `completion` and `progress` closures to observe status and result.
    ///
    /// - Note:
    ///   - This method is intended for use in environments that do not support `async/await` directly.
    ///     For full control and task cancellation, use the `async` variant instead.
    ///   - Errors thrown during async execution will be caught and transformed into a `.failure(.uploadFailed(...))` result.
    ///
    /// - Example Usage:
    ///   ```swift
    ///   networking.uploadRawData(
    ///       to: URL(string: "https://api.example.com/file")!,
    ///       data: myData,
    ///       headers: ["Authorization": "Bearer token"],
    ///       progress: { progress in
    ///           print("Progress: \(progress * 100)%")
    ///       },
    ///       completion: { (response: NetworkingResponse<MyModel>) in
    ///           switch response.result {
    ///           case .success(let model):
    ///               print("Upload succeeded:", model)
    ///           case .failure(let error):
    ///               print("Upload failed:", error)
    ///           }
    ///       }
    ///   )
    ///   ```
    ///
    /// - Thread Safety:
    ///   - Safe to call from any thread.
    ///   - The internal `Task` runs asynchronously; progress and completion closures may be called from background threads.
    ///     Dispatch back to the main thread for any UI updates.
    @discardableResult
    public func uploadRawData<T: Decodable>(to url: URL, method: HTTPMethod = .post, data: Data, headers: HTTPHeaders? = nil, progress: ((Double) -> Void)?, completion: @escaping (NetworkingResponse<T>) -> Void) -> URLSessionUploadTask? {
        return uploader.uploadRawData(to: url, method: method, data: data, headers: headers, progress: progress, completion: completion)
    }
    
    /// Asynchronously uploads raw binary data to a specified server endpoint.
    ///
    /// This method is ideal for uploading a single binary file (e.g., image, video, PDF) without any additional form fields.
    /// It sends the data directly using the `application/octet-stream` content type, and manages the request through a `URLSessionUploadTask`.
    /// Suitable for modern Swift concurrency usage via `async/await`.
    ///
    /// - Parameters:
    ///   - url: The `URL` to which the binary data will be uploaded.
    ///          - This should point to a server endpoint capable of handling raw uploads.
    ///
    ///   - method: The HTTP method to use for the upload (default: `.post`).
    ///             - Common values include `.post` and `.put`, depending on API design.
    ///
    ///   - data: The raw binary `Data` to upload.
    ///           - Typically read from disk or generated in-memory (e.g., image compression output).
    ///
    ///   - headers: Optional `HTTPHeaders` dictionary for authentication, custom content-type, etc.
    ///              - These headers will override the default `Content-Type` if provided explicitly.
    ///
    ///   - progress: An optional closure that reports upload progress as a `Double` in the range `0.0...1.0`.
    ///               - Use this to drive progress bars or background activity indicators.
    ///
    ///   - completion: A closure called when the upload completes, returning a `NetworkingResponse<T>`:
    ///                 - `.success(T)`: If the server returns a valid response and it is successfully decoded.
    ///                 - `.failure(NetworkError)`: If a network, decoding, or connection error occurs.
    ///
    /// - Returns:
    ///   - A `URLSessionUploadTask?` representing the upload task if it was successfully started.
    ///     Returns `nil` if the request could not be constructed or network prerequisites failed.
    ///
    /// - Note:
    ///   - The `Content-Type` is set to `application/octet-stream` by default.
    ///     This is suitable for binary payloads such as:
    ///     - `.jpg`, `.png`, `.gif` (images)
    ///     - `.pdf`, `.docx`, `.zip` (documents)
    ///     - `.mp4`, `.mov` (videos)
    ///   - This method does **not** support sending additional form fields. Use `uploadMultipart(...)` for that case.
    ///   - Uploads cannot be resumed if interrupted (`resumeData` is not available for raw uploads).
    ///   - The `@discardableResult` annotation allows the task to be ignored if return value is not needed.
    ///
    /// - Example Usage:
    ///   ```swift
    ///   let fileData = try Data(contentsOf: imageURL)
    ///
    ///   let task = try await networking.uploadRawData(
    ///       to: URL(string: "https://api.example.com/upload")!,
    ///       method: .put,
    ///       data: fileData,
    ///       headers: ["Authorization": "Bearer token"],
    ///       progress: { progress in
    ///           print("Upload progress: \(progress * 100)%")
    ///       },
    ///       completion: { (response: NetworkingResponse<UploadResult>) in
    ///           switch response.result {
    ///           case .success(let result):
    ///               print("Upload successful: \(result)")
    ///           case .failure(let error):
    ///               print("Upload failed: \(error)")
    ///           }
    ///       }
    ///   )
    ///   ```
    ///
    /// - Thread Safety:
    ///   - Safe to call from any async context (e.g., view models, background tasks).
    ///   - Internal state (such as `activeUploads`) is protected via locking mechanisms.
    ///   - `progress` and `completion` closures may be called on background threads; dispatch to main thread for UI updates.
    @discardableResult
    public func uploadRawData<T: Decodable>(to url: URL, method: HTTPMethod = .post, data: Data, headers: HTTPHeaders? = nil, progress: ((Double) -> Void)?, completion: @escaping (NetworkingResponse<T>) -> Void) async throws -> URLSessionUploadTask? {
        return try await uploader.uploadRawData(to: url, method: method, data: data, headers: headers, progress: progress, completion: completion)
    }
    
    /// Uploads a file from disk using a synchronous-style API that internally performs the operation asynchronously.
    ///
    /// This method wraps the async version of `uploadFile(...)` inside a `Task`, allowing use in contexts that do not support `async/await`.
    /// It streams the file directly from a local URL to the server using a `URLSessionUploadTask`, making it ideal for large files that should not be loaded into memory.
    /// Result and progress updates are delivered via closure-based callbacks.
    ///
    /// - Parameters:
    ///   - localFileURL: The `URL` of the file on disk to be uploaded.
    ///                   - The file must exist at this location and be accessible.
    ///
    ///   - remoteURL: The server endpoint to which the file will be uploaded.
    ///                - Typically a REST API endpoint designed to receive media, documents, or assets.
    ///
    ///   - method: The HTTP method to use (default: `.post`).
    ///             - `.post` or `.put` are generally used for file uploads.
    ///
    ///   - headers: Optional HTTP headers to include in the request.
    ///              - Useful for authorization, content type overrides, or custom backend requirements.
    ///
    ///   - progress: An optional closure reporting upload progress as a `Double` between `0.0` and `1.0`.
    ///               - Can be used to update progress bars or track network activity.
    ///
    ///   - completion: A closure returning a `NetworkingResponse<T>`:
    ///                 - `.success(T)`: Upload completed and response decoded successfully.
    ///                 - `.failure(NetworkError)`: Upload failed or the server response could not be decoded.
    ///
    /// - Returns:
    ///   - Always returns `nil`, as the underlying task is managed internally by an `async` `Task`.
    ///     - The result must be handled through the `completion` closure.
    ///
    /// - Note:
    ///   - This method is useful in UIKit or Combine-based systems that are not yet fully `async/await`-enabled.
    ///   - Errors thrown during the upload will be caught and returned via the `completion` closure as `.failure(.uploadFailed(error))`.
    ///   - This is a memory-efficient approach since it streams the file directly from disk.
    ///
    /// - Example Usage:
    ///   ```swift
    ///   networking.uploadFile(
    ///       from: fileURL,
    ///       to: URL(string: "https://api.example.com/upload")!,
    ///       headers: ["Authorization": "Bearer token"],
    ///       progress: { progress in
    ///           print("Upload progress: \(progress * 100)%")
    ///       },
    ///       completion: { (response: NetworkingResponse<MyResponseModel>) in
    ///           switch response.result {
    ///           case .success(let result):
    ///               print("Upload succeeded:", result)
    ///           case .failure(let error):
    ///               print("Upload failed:", error)
    ///           }
    ///       }
    ///   )
    ///   ```
    ///
    /// - Thread Safety:
    ///   - Safe to invoke from any thread.
    ///   - Underlying `Task` executes asynchronously in the background.
    ///   - Ensure UI updates in `progress` and `completion` closures are dispatched to the main thread when needed.
    @discardableResult
    public func uploadFile<T: Decodable>(from localFileURL: URL, to remoteURL: URL, method: HTTPMethod = .post, headers: HTTPHeaders? = nil, progress: ((Double) -> Void)?, completion: @escaping (NetworkingResponse<T>) -> Void) -> URLSessionUploadTask? {
        return uploader.uploadFile(from: localFileURL, to: remoteURL, method: method, headers: headers, progress: progress, completion: completion)
    }
    
    /// Uploads a file directly from a local file URL to a remote server using an asynchronous API.
    ///
    /// This method streams the file directly from disk using `URLSessionUploadTask`, allowing you to upload large files efficiently without loading them into memory.
    /// It is well-suited for file uploads in high-performance or memory-sensitive applications, such as sending videos, documents, or images.
    ///
    /// - Parameters:
    ///   - localFileURL: The local file system `URL` of the file to be uploaded.
    ///                   - The file must exist and be readable at this path.
    ///
    ///   - remoteURL: The server-side endpoint (`URL`) to which the file should be uploaded.
    ///                - Typically a REST API URL accepting PUT or POST uploads.
    ///
    ///   - method: The `HTTPMethod` used for the upload (default: `.post`).
    ///             - Accepted values typically include `.post` and `.put`.
    ///
    ///   - headers: Optional HTTP headers to include with the request.
    ///              - These can override default values like `Content-Type`.
    ///              - Common headers include `Authorization`, `Content-Length`, or `X-API-Key`.
    ///
    ///   - progress: An optional closure reporting upload progress as a `Double` (0.0...1.0).
    ///               - This can be used to drive progress bars or display transfer stats.
    ///
    ///   - completion: A closure called when the upload finishes, returning a `NetworkingResponse<T>`:
    ///                 - `.success(T)`: Indicates the response was decoded successfully.
    ///                 - `.failure(NetworkError)`: Indicates that the upload failed or the response was invalid.
    ///
    /// - Returns:
    ///   - A `URLSessionUploadTask?` instance if the upload is successfully started; otherwise `nil`.
    ///     - You may store the returned task for potential cancellation.
    ///
    /// - Note:
    ///   - The file is streamed directly from disk, making this more memory-efficient than converting to `Data`.
    ///   - If the upload is interrupted, it **cannot be resumed** (no `resumeData` support for `fromFile:` API).
    ///   - MIME type can be inferred or set manually via headers (e.g., `video/mp4`, `application/pdf`).
    ///   - Suitable for:
    ///     - Large media files: `.mp4`, `.mov`, `.avi`
    ///     - High-res images: `.png`, `.jpg`
    ///     - Documents: `.pdf`, `.docx`, `.zip`
    ///
    /// - Example Usage:
    ///   ```swift
    ///   let task = try await networking.uploadFile(
    ///       from: fileURL,
    ///       to: URL(string: "https://api.example.com/upload")!,
    ///       headers: ["Authorization": "Bearer token"],
    ///       progress: { percent in
    ///           print("Progress: \(percent * 100)%")
    ///       },
    ///       completion: { (response: NetworkingResponse<UploadResult>) in
    ///           switch response.result {
    ///           case .success(let result):
    ///               print("Upload successful:", result)
    ///           case .failure(let error):
    ///               print("Upload failed:", error)
    ///           }
    ///       }
    ///   )
    ///   ```
    ///
    /// - Thread Safety:
    ///   - Can be safely invoked from any thread.
    ///   - The `activeUploads` dictionary is accessed within a locked `DispatchQueue`.
    ///   - `progress` and `completion` closures may be called on a background thread; dispatch to the main thread if needed for UI updates.
    @discardableResult
    public func uploadFile<T: Decodable>(from localFileURL: URL, to remoteURL: URL, method: HTTPMethod = .post, headers: HTTPHeaders? = nil, progress: ((Double) -> Void)?, completion: @escaping (NetworkingResponse<T>) -> Void) async throws -> URLSessionUploadTask? {
        return try await uploader.uploadFile(from: localFileURL, to: remoteURL, method: method, headers: headers, progress: progress, completion: completion)
    }
    
    /// Uploads form-encoded data using a synchronous-style interface that internally performs an async upload.
    ///
    /// This method wraps the async `uploadFormURLEncoded(...)` function in a `Task`, allowing compatibility with non-async code.
    /// It encodes the given parameters as `application/x-www-form-urlencoded` and sends them in the body of an HTTP request.
    /// Result and progress are reported through closures, making this ideal for UIKit-based apps or legacy codebases.
    ///
    /// - Parameters:
    ///   - url: The endpoint `URL` to which the form data will be submitted.
    ///          - Typically used for login, search, filtering, or simple form submissions.
    ///
    ///   - method: The HTTP method to use for the request (default: `.post`).
    ///             - Common values include `.post` and `.put`.
    ///
    ///   - parameters: A dictionary of form fields to be encoded in the HTTP body.
    ///                 - Values will be stringified and percent-encoded for compatibility with URL encoding standards.
    ///
    ///   - headers: Optional HTTP headers to include in the request.
    ///              - Examples: `Authorization`, `Accept-Language`, `X-Client-Version`.
    ///
    ///   - progress: An optional closure called periodically with upload progress as a `Double` from `0.0` to `1.0`.
    ///               - Use this to reflect progress in UI elements.
    ///
    ///   - completion: A closure that is invoked when the upload finishes.
    ///                 - Returns a `NetworkingResponse<T>`:
    ///                   - `.success(T)`: The server response was successfully decoded.
    ///                   - `.failure(NetworkError)`: An error occurred during the request or decoding.
    ///
    /// - Returns:
    ///   - Always returns `nil`, as the actual `URLSessionUploadTask` is encapsulated inside an async `Task`.
    ///     - Use `completion` and `progress` to monitor the result and status.
    ///
    /// - Note:
    ///   - This is a memory-efficient alternative to multipart form uploads, ideal for small payloads and form-style data.
    ///   - Parameters are serialized to `key=value&key2=value2` and percent-encoded automatically.
    ///   - Use this method in situations where `async/await` is not yet supported or not ideal (e.g., UIKit actions, delegates).
    ///
    /// - Example Usage:
    ///   ```swift
    ///   networking.uploadFormURLEncoded(
    ///       to: URL(string: "https://api.example.com/auth")!,
    ///       parameters: [
    ///           "email": "user@example.com",
    ///           "password": "securepass123"
    ///       ],
    ///       headers: ["Authorization": "Bearer token"],
    ///       progress: { progress in
    ///           print("Progress: \(progress * 100)%")
    ///       },
    ///       completion: { (response: NetworkingResponse<LoginResponse>) in
    ///           switch response.result {
    ///           case .success(let token):
    ///               print("Authenticated:", token)
    ///           case .failure(let error):
    ///               print("Auth failed:", error)
    ///           }
    ///       }
    ///   )
    ///   ```
    ///
    /// - Thread Safety:
    ///   - This method is safe to call from any thread.
    ///   - The `progress` and `completion` closures may be invoked from background threads.
    ///     - If updating UI elements, ensure dispatch to the main thread using `DispatchQueue.main.async { ... }`.
    @discardableResult
    public func uploadFormURLEncoded<T: Decodable>(to url: URL, method: HTTPMethod = .post, parameters: Parameters, headers: HTTPHeaders? = nil, progress: ((Double) -> Void)?, completion: @escaping (NetworkingResponse<T>) -> Void) -> URLSessionUploadTask? {
        return uploader.uploadFormURLEncoded(to: url, method: method, parameters: parameters, headers: headers, progress: progress, completion: completion)
    }
    
    /// Uploads URL-encoded form parameters using an asynchronous HTTP request.
    ///
    /// This method encodes key-value pairs as `application/x-www-form-urlencoded` content
    /// and sends them in the HTTP body. It is ideal for submitting form-like data to APIs,
    /// especially in situations where the payload does not include files or binary content.
    ///
    /// - Parameters:
    ///   - url: The server `URL` to which the form data will be submitted.
    ///          - Typically a login, registration, or API submission endpoint.
    ///
    ///   - method: The HTTP method used to send the form data (default: `.post`).
    ///             - Common values include `.post` and `.put`, depending on the API’s expectations.
    ///
    ///   - parameters: A dictionary of form fields to be encoded as a query string.
    ///                 - Values are automatically converted to their string representations and percent-encoded.
    ///
    ///   - headers: Optional `HTTPHeaders` to include with the request.
    ///              - Can be used for authentication or other custom headers.
    ///              - Any provided `Content-Type` here will override the default form encoding.
    ///
    ///   - progress: An optional closure reporting upload progress as a `Double` between `0.0` and `1.0`.
    ///               - Suitable for updating progress indicators in UI.
    ///
    ///   - completion: A closure called when the request finishes.
    ///                 - Returns a `NetworkingResponse<T>` where:
    ///                   - `.success(T)`: The response was successfully decoded into the target type.
    ///                   - `.failure(NetworkError)`: An error occurred during the request or decoding.
    ///
    /// - Returns:
    ///   - A `URLSessionUploadTask?` instance representing the underlying upload request, or `nil` if the task could not be created.
    ///
    /// - Note:
    ///   - This method is designed for simple key-value submission and **does not support file uploads**.
    ///   - All parameters are percent-encoded and concatenated into the request body (`key1=value1&key2=value2`).
    ///   - Special characters such as `=`, `&`, and spaces will be properly encoded to avoid server-side parsing issues.
    ///   - The default `Content-Type` is `application/x-www-form-urlencoded`, but you may override it via `headers`.
    ///   - The request is sent using `URLSessionUploadTask` and begins immediately after creation via `resume()`.
    ///
    /// - Example Usage:
    ///   ```swift
    ///   let task = try await networking.uploadFormURLEncoded(
    ///       to: URL(string: "https://api.example.com/login")!,
    ///       parameters: [
    ///           "username": "john.doe",
    ///           "password": "s3cr3t"
    ///       ],
    ///       headers: ["Authorization": "Bearer token"],
    ///       progress: { percent in
    ///           print("Progress: \(percent * 100)%")
    ///       },
    ///       completion: { (response: NetworkingResponse<AuthToken>) in
    ///           switch response.result {
    ///           case .success(let token):
    ///               print("Login successful:", token)
    ///           case .failure(let error):
    ///               print("Login failed:", error)
    ///           }
    ///       }
    ///   )
    ///   ```
    ///
    /// - Thread Safety:
    ///   - This method is safe to invoke from any thread.
    ///   - Shared state (such as `activeUploads`) is accessed via a synchronization queue.
    ///   - The `progress` and `completion` closures may be called on background threads; dispatch to the main thread when updating UI.
    @discardableResult
    public func uploadFormURLEncoded<T: Decodable>(to url: URL, method: HTTPMethod = .post, parameters: Parameters, headers: HTTPHeaders? = nil, progress: ((Double) -> Void)?, completion: @escaping (NetworkingResponse<T>) -> Void) async throws -> URLSessionUploadTask? {
        return try await uploader.uploadFormURLEncoded(to: url, method: method, parameters: parameters, headers: headers, progress: progress, completion: completion)
    }
    
    /// Cancels an ongoing upload task.
    ///
    /// - This method stops an active `URLSessionUploadTask` that is currently in progress.
    /// - If the task supports **resume data**, it may be possible to restart the upload from where it left off.
    /// - The upload task is removed from `activeUploads` once canceled.
    ///
    /// - Parameter task: The `URLSessionTask` representing the upload task to be canceled.
    ///
    /// - Note:
    ///   - If the server supports **resume data**, canceling the task **may** generate `resumeData`,
    ///     which can be used to restart the upload later.
    ///   - If **resuming is needed**, consider using `pauseUpload(task:completion:)` instead of canceling.
    ///   - Tasks that do **not** support resumable uploads will be **completely stopped** and must restart from scratch.
    ///   - This method ensures **thread-safe access** to `activeUploads` using `lockQueue`.
    ///
    /// - Thread Safety:
    ///   - The method locks `activeUploads` using `lockQueue.sync` to prevent race conditions.
    public func cancelUpload(task: URLSessionTask) {
        uploader.cancelUpload(task: task)
    }
    
    /// Cancels all ongoing upload tasks.
    ///
    /// - This method stops all active uploads managed by the `Uploader`.
    /// - If the upload tasks support **resume data**, consider using `pauseUpload()` instead of canceling them.
    /// - Any in-progress uploads will be removed from `activeUploads`.
    ///
    /// - Note:
    ///   - If the server supports **resume data**, canceling an upload **may** generate `resumeData`,
    ///     which can be used to restart the upload later.
    ///   - Uploads that do **not** support resumable transfers will be **completely lost**, requiring a full restart.
    ///   - Progress handlers for ongoing uploads will no longer receive updates.
    ///   - This method ensures **thread-safe access** to `activeUploads` using `lockQueue`.
    ///
    /// - Thread Safety:
    ///   - The method locks `activeUploads` using `lockQueue.sync` to prevent race conditions.
    public func cancelAllUploads() {
        uploader.cancelAllUploads()
    }
    
}
